# Extension Polidrom string

<p align="center">
<img src="https://media.giphy.com/media/ZBDh3VeZjBMfS/giphy.gif">
</p>
<br>

```C#
public static bool isSymmetrical(this string word)
{
            for (int i = 0; i < word.Length; i++)
            {
                if (word[i] != word[word.Length - 1 - i])
                return false;
            }
            return true;
}
 
//Testing

string st1 = "Anna";
string st2 = "AramarA";
string st3 = "aNNa";
string st4 = "ՀայաՀ";
string st5 = Console.ReadLine();
Console.WriteLine(st1.isSymmetrical());//false
Console.WriteLine(st2.isSymmetrical());//true
Console.WriteLine(st3.isSymmetrical());//true
Console.WriteLine(st4.isSymmetrical());//true
Console.WriteLine(st5.isSymmetrical());

```

### About palindrome
<br>
<p>A <b>palindrome</b> is a word, phrase, <a href="https://en.wikipedia.org/wiki/Palindromic_number" title="Palindromic number">number</a>, or other sequence of <a href="https://en.wikipedia.org/wiki/Character_(symbol)" title="Character (symbol)">characters</a> which reads the same backward or forward, such as <i>madam</i> or <i>kayak</i>. Sentence-length palindromes may be written when allowances are made for adjustments to capital letters, punctuation, and word dividers, such as "A man, a plan, a canal, Panama!", "Was it a car or a cat I saw?" or "No 'x' in Nixon".</p>



### About Extension methods

<p></p><p>Extension methods are defined as static methods but are called by using instance method syntax. Their first parameter specifies which type the method operates on, and the parameter is preceded by the <a href="https://msdn.microsoft.com/en-us/library/dk1507sz.aspx">this</a> modifier. Extension methods are only in scope when you explicitly import the namespace into your source code with a <code>using</code> directive.</p><p>The following example shows an extension method defined for the <a href="https://msdn.microsoft.com/en-us/library/system.string.aspx">System.String</a> class. Note that it is defined inside a non-nested, non-generic static class:</p>
<br>
``` c#

namespace ExtensionMethods
{
    public static class MyExtensions
    {
        public static int WordCount(this String str)
        {
            return str.Split(new char[] { ' ', '.', '?' }, 
                             StringSplitOptions.RemoveEmptyEntries).Length;
        }
    }   
}
```    
     
        
        
And it can be called from an application by using this syntax:
In your code you invoke the extension method with instance method syntax. However, the intermediate language (IL) generated by the compiler translates your code into a call on the static method. Therefore, the principle of encapsulation is not really being violated. In fact, extension methods cannot access private variables in the type they are extending.
